# downloader.py
import re
import subprocess
import tempfile
from pathlib import Path


class DownloadError(Exception):
    """ä¸‹è½½å¤±è´¥æ—¶æŠ›å‡ºçš„å¼‚å¸¸"""
    pass


# yt-dlp åŸºç¡€å‚æ•°ï¼šå¯ç”¨ EJS è§£é¢˜å™¨ä»¥é€šè¿‡ YouTube åçˆ¬éªŒè¯
_YT_DLP_BASE = ["yt-dlp", "--remote-components", "ejs:github"]


def _sanitize_filename(name: str) -> str:
    """å°†è§†é¢‘æ ‡é¢˜è½¬ä¸ºå®‰å…¨çš„æ–‡ä»¶å"""
    name = re.sub(r'[\\/*?:"<>|]', '', name)
    name = re.sub(r'\s+', '_', name.strip())
    return name[:200] if name else "untitled"


def _write_cookies_file(cookies: list[dict]) -> Path:
    """å°† Chrome Extension ä¼ æ¥çš„ cookies åˆ—è¡¨å†™æˆ Netscape æ ¼å¼çš„ä¸´æ—¶æ–‡ä»¶"""
    tmp = tempfile.NamedTemporaryFile(
        mode="w", suffix=".txt", prefix="yt2text_cookies_", delete=False
    )
    tmp.write("# Netscape HTTP Cookie File\n")
    tmp.write("# Generated by yt2text Chrome Extension\n\n")
    for c in cookies:
        domain = c.get("domain", "")
        include_subdomains = "TRUE" if domain.startswith(".") else "FALSE"
        path = c.get("path", "/")
        secure = "TRUE" if c.get("secure") else "FALSE"
        expires = int(c.get("expirationDate", 0))
        name = c.get("name", "")
        value = c.get("value", "")
        tmp.write(f"{domain}\t{include_subdomains}\t{path}\t{secure}\t{expires}\t{name}\t{value}\n")
    tmp.close()
    return Path(tmp.name)


def _get_cookie_args(cookies: list[dict] | None, browser: str | None) -> tuple[list[str], Path | None]:
    """è¿”å› (yt-dlp cookie å‚æ•°åˆ—è¡¨, ä¸´æ—¶æ–‡ä»¶è·¯å¾„ or None)
    ä¼˜å…ˆä½¿ç”¨ Extension ä¼ æ¥çš„ cookiesï¼Œå…¶æ¬¡ --cookies-from-browser"""
    if cookies:
        cookie_file = _write_cookies_file(cookies)
        print(f"ğŸª ä½¿ç”¨ Chrome Extension cookies ({len(cookies)} æ¡)")
        return ["--cookies", str(cookie_file)], cookie_file
    if browser:
        print(f"ğŸª ä½¿ç”¨æµè§ˆå™¨ cookies: {browser}")
        return ["--cookies-from-browser", browser], None
    return [], None


def _get_video_title(url: str, cookies: list[dict] | None = None, browser: str | None = None) -> str:
    """è·å–è§†é¢‘æ ‡é¢˜"""
    cookie_args, cookie_file = _get_cookie_args(cookies, browser)
    command = _YT_DLP_BASE + ["--print", "title", url] + cookie_args

    try:
        result = subprocess.run(command, capture_output=True, text=True)
        if result.returncode == 0 and result.stdout.strip():
            return result.stdout.strip()
        if result.stderr.strip():
            print(f"   âš ï¸  yt-dlp stderr: {result.stderr.strip()}")
    finally:
        if cookie_file:
            cookie_file.unlink(missing_ok=True)
    return ""


def _parse_download_error(stderr: str) -> str:
    """è§£æä¸‹è½½é”™è¯¯å¹¶è¿”å›å‹å¥½æç¤ºä¿¡æ¯"""
    if "members" in stderr.lower() or "member" in stderr.lower():
        return "è¯¥è§†é¢‘ä¸ºé¢‘é“ä¼šå‘˜ä¸“å±å†…å®¹ï¼Œéœ€è¦ç™»å½•ä¿¡æ¯æ‰èƒ½ä¸‹è½½ã€‚è¯·ç¡®è®¤ä½ å·²åœ¨ Chrome ä¸­ç™»å½• YouTube ä¸”ä¸ºè¯¥é¢‘é“ä¼šå‘˜ã€‚"
    elif "private" in stderr.lower():
        return "è¯¥è§†é¢‘ä¸ºç§å¯†è§†é¢‘ï¼Œæ— æ³•ä¸‹è½½ã€‚"
    elif "unavailable" in stderr.lower() or "not available" in stderr.lower():
        return "è¯¥è§†é¢‘ä¸å¯ç”¨ï¼ˆå¯èƒ½å·²è¢«åˆ é™¤æˆ–å­˜åœ¨åœ°åŒºé™åˆ¶ï¼‰ã€‚"
    else:
        return f"ä¸‹è½½å¤±è´¥ï¼š{stderr.strip()}"


def download_audio(url: str, output_dir: str = "output", browser: str = None, cookies: list[dict] | None = None, title: str | None = None) -> Path:
    Path(output_dir).mkdir(exist_ok=True)

    # ä¼˜å…ˆä½¿ç”¨ Extension ä¼ æ¥çš„æ ‡é¢˜ï¼Œçœå» yt-dlp å–æ ‡é¢˜çš„è€—æ—¶
    if not title:
        print("ğŸ“‹ è·å–è§†é¢‘æ ‡é¢˜...")
        title = _get_video_title(url, cookies=cookies, browser=browser)
    if not title:
        print("âš ï¸  æ— æ³•è·å–è§†é¢‘æ ‡é¢˜ï¼Œä½¿ç”¨é»˜è®¤æ–‡ä»¶å")
        safe_title = "audio"
    else:
        safe_title = _sanitize_filename(title)
        print(f"   æ ‡é¢˜: {title}")

    audio_path = Path(output_dir) / f"{safe_title}.opus"

    # å…¼å®¹æ—§ç¼“å­˜ï¼šæ£€æŸ¥ .opus å’Œ .mp3
    for ext in (".opus", ".mp3"):
        candidate = Path(output_dir) / f"{safe_title}{ext}"
        if candidate.exists() and candidate.stat().st_size > 0:
            print(f"â© éŸ³é¢‘æ–‡ä»¶å·²å­˜åœ¨ï¼Œè·³è¿‡ä¸‹è½½: {candidate}")
            return candidate

    output_template = f"{output_dir}/{safe_title}.%(ext)s"
    cookie_args, cookie_file = _get_cookie_args(cookies, browser)

    command = _YT_DLP_BASE + [
        "-f", "ba[abr<=64]/wa/ba",   # é€‰æœ€å°éŸ³é¢‘æµï¼Œè¯­éŸ³è¯†åˆ«æ— éœ€é«˜éŸ³è´¨
        "-x",
        "--audio-format", "opus",     # ä¿æŒ opus åŸç”Ÿæ ¼å¼ï¼Œè·³è¿‡ mp3 è½¬ç 
        "--no-playlist",
        url,
        "-o", output_template,
    ] + cookie_args

    try:
        print(f"   â–¶ yt-dlp å¼€å§‹ä¸‹è½½...")
        result = subprocess.run(command, capture_output=True, text=True)
        # æ‰“å° yt-dlp è¾“å‡ºä»¥ä¾¿è¯Šæ–­è€—æ—¶
        if result.stdout.strip():
            for line in result.stdout.strip().split("\n"):
                print(f"   [yt-dlp] {line}")
        if result.returncode != 0:
            print(f"   âŒ yt-dlp stderr:\n{result.stderr.strip()}")
            msg = _parse_download_error(result.stderr)
            raise DownloadError(msg)
    finally:
        if cookie_file:
            cookie_file.unlink(missing_ok=True)

    # yt-dlp å®é™…è¾“å‡ºçš„æ–‡ä»¶åå¯èƒ½ä¸é¢„æœŸä¸åŒï¼Œåšä¸€æ¬¡ç¡®è®¤
    if not audio_path.exists():
        for ext in (".opus", ".webm", ".m4a", ".ogg", ".mp3"):
            candidate = Path(output_dir) / f"{safe_title}{ext}"
            if candidate.exists() and candidate.stat().st_size > 0:
                audio_path = candidate
                break

    return audio_path
